  def divideCashesToTotalAmount(amount:Int) {
    val display = new Display()
    val server = new ServerMachine()

    var dividedCashes:ListMap[String, Int] = ListMap.empty
    amountCategory.foreach {
      case (key, value) =>
        var divided = amount / value
        if (divided > machineBalance(key)) divided = machineBalance(key)
        dividedCashes += key -> divided
    }
    display.message(s"Divided cashes : $dividedCashes")

    if (calculateTotalAmount(dividedCashes) <= machineBalance("total")) {
      display.message("Calculate possibilities!")
      var targetAmount:Int = 0
      var separatedCashes:ListMap[String, Int] = ListMap.empty
      dividedCashes.foreach {
        case (key, value) =>
          var isMoneyPicked:Boolean = false
          var count:Int = value
          breakable {
            while (count > 0) {
              if ((targetAmount + (amountCategory(key) * count)) <= amount) {
                targetAmount += (amountCategory(key) * count)
                separatedCashes += key -> count
                isMoneyPicked = true
                break()
              }
              count -= 1
            }
          }
          if (!isMoneyPicked) separatedCashes += key -> 0
          display.message(s"separated cashes : $separatedCashes")
      }
      if (calculateTotalAmount(separatedCashes) == amount) {
        display.message("we can give")
        var updatedCash:ListMap[String, Int] = ListMap.empty
        separatedCashes.foreach {
          case (key, value) =>
            updatedCash += key -> (machineBalance(key) - value)
        }
        updatedCash += "total" -> calculateTotalAmount(updatedCash)
        display.message(s"Machine balance = $machineBalance")
        display.message(s"separated cash = $separatedCashes")
        display.message(s"Updated cash = $updatedCash")
        server.updateMoneyAfterWithdraw(amount, cardData("accountNumber"))
        giveMoneyToUser(separatedCashes)
        machineBalance = updatedCash
      } else display.message("Not available cashes for this amount!")
    } else display.message("Not enough amount available! try again after some time ")
  }



    def createNewAccount() {
      val display = new Display()
      val server = new ServerMachine()

      display.message("\n:- CREATE NEW ACCOUNT -:")
      val accountDataMessages:ListMap[String, String] = ListMap("name" -> "Enter your name : ", "accountNumber" -> "Enter account number : ", "pin" -> "Enter your pin : ", "age" -> "Enter your age : ")
      val userData:ListMap[String, String] = getDataFromUser(accountDataMessages)
      if (userData("isCancelled").equals("false")) {
        val isNewAccountCreated = server.createNewAccount(userData)
        if (!isNewAccountCreated) {
          createNewAccount()
        }
      } else {
        display.message("Process cancelled!")
      }
    }



  def createNewAccount(data:ListMap[String, String]): ListMap[String, Int] = {
    var processStatus:ListMap[String, Int] = ListMap.empty
    var dbConnection:Connection = null
    try {
      dbConnection = DriverManager.getConnection(url, user, password)
      val query = "INSERT INTO account(name, account_number, pin, age) VALUES (?, ?, ?, ?)"
      var statement = dbConnection.prepareStatement(query)
      statement.setString(1, data("name"))
      statement.setString(2, data("accountNumber"))
      statement.setInt(3, data("pin").toInt)
      statement.setInt(4, data("age").toInt)
      statement.execute()
      val setBalanceQuery = "INSERT INTO balance(balance, account_number) VALUES (0, ?)"
      statement = dbConnection.prepareStatement(setBalanceQuery)
      statement.setString(1, data("accountNumber"))
      statement.execute()
      processStatus = ListMap("status" -> 200)
    } catch {
        case exception:Exception => processStatus = ListMap("status" -> 429)
    }
    processStatus
  }

    def isExistingAccount(newAccountNumber:String): Boolean = {
      var isExists:Boolean = false
      var dbConnection:Connection = null
      try {
        dbConnection = DriverManager.getConnection(url, user, password)
        dbConnection = DriverManager.getConnection(url, user, password)
        var existingAccountNumbers:List[String] = List.empty
        val query = "SELECT account_number FROM account"
        val statement = dbConnection.createStatement()
        val result = statement.executeQuery(query)
        while (result.next()) {
          existingAccountNumbers = result.getString(1) :: existingAccountNumbers
        }
        isExists = existingAccountNumbers.contains(newAccountNumber)
      } catch {
          case exception:Exception => exception.getMessage
      }
      isExists
    }


  def createNewAccount(data:ListMap[String, String]): Boolean = {
    val db = new DBManager()
    val display = new Display()
    val isExistingAccount = db.isExistingAccount(data("accountNumber"))
    var processStatus:ListMap[String, Int] = ListMap.empty
    if (isExistingAccount) processStatus = ListMap("status" -> 409)
    else processStatus = db.createNewAccount(data)
    display.createAccountStatus(processStatus)
  }


    def createAccountStatus(status:ListMap[String, Int]): Boolean = {
      if (status("status") == 200) {
        println("Account created successfully!")
        return true
      } else if (status("status") == 409) {
        println("Account already exist")
      } else {
        println("Unsuccessful")
      }
      false
    }


  def getDataFromUser(dataMessages:ListMap[String, String]) : ListMap[String, String] = {
    var userData = ListMap.empty[String, String]
    var isCancelled = false
    breakable {
      dataMessages.foreach {
        case (key, value) => {
          val display = new Display()
          var isValidInput = false
          val clientInput = display.getUserInput(value)
          if (clientInput.equals("cancel")) {
            isCancelled = true
            break()
          }
          else {
            val validate = new Validation()
            isValidInput = validate.isValidInput(key, clientInput)
            if (isValidInput) {
              userData += (key -> clientInput)
            }
            else {
              display.message("Please check your input! (invalid input found)")
            }
          }
        }
      }
    }
    userData += ("isCancelled" -> isCancelled.toString)
    userData
  }